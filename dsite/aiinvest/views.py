

# Create your views here.
from django.shortcuts import render, get_object_or_404

from django.http import HttpResponse, HttpResponseRedirect
from django.template import loader
from django.http import Http404
from django.urls import reverse
from django.views import generic
from django.utils import timezone

from .models import AssetData, AssetList

# Each generic view needs to know what model it will be acting upon. This is provided using either the model attribute (in this example, model = Question for DetailView and ResultsView) or by defining the get_queryset() method (as shown in IndexView).
class IndexView(generic.ListView):
    template_name = "aiinvest/index.html"
    
    # For DetailView the question variable is provided automatically – since we’re using a Django model (Question), Django is able to determine an appropriate name for the context variable. However, for ListView, the automatically generated context variable is question_list. To override this we provide the context_object_name attribute, specifying that we want to use latest_question_list instead.
    context_object_name = "asset_data_list"

    def get_queryset(self):
        """
        to overide the get_queryset function.
        """
        ...
        # return Question.objects.filter(pub_date__lte=timezone.now()).order_by("-pub_date")[
        #     :5
        # ]

# By default, the DetailView generic view uses a template called <app name>/<model name>_detail.html. In our case, it would use the template "polls/question_detail.html". The template_name attribute is used to tell Django to use a specific template name instead of the autogenerated default template name. 
def detail(request,asset_name=""):

    # That code loads the template called aiinvest/index.html 
    template = loader.get_template("aiinvest/detail.html")

    asset_data = get_object_or_404(AssetData, asset_name=asset_name)

    context = {
            "asset_data": asset_data,
        }

    # passes the template a context. The context is a dictionary mapping template variable names to Python objects.
    return HttpResponse(template.render(context,request))


class Result:

    @classmethod
    def result(cls, request):

        if request:

            try:

                if request.method == 'POST':

                    ticker1 = request.POST.get('ticker1')
                    tickers, values = cls.get_tickers(request)
                    context = {
                    "asset_data": "Place Holder",
                    "tickers": tickers,
                    "values": values,
                    }
                    ############### here to add the data processing function ######
                    ###### and add the results of the data to the contxt #############
                    # That code loads the template called aiinvest/index.html 
                    template = loader.get_template("aiinvest/result.html")
                    # passes the template a context. The context is a dictionary mapping template variable names to Python objects.
                    return HttpResponse(template.render(context,request))
                else:
                    return render(
                    request,
                    "aiinvest/index.html",
                    {
                        # one for error_message
                        "error_message": "Please input your portfolio information",
                    },
                )
            except ValueError as e:
            # Redisplay the portforlio input page.
                return render(
                    request,
                    "aiinvest/index.html",
                    {
                        # one for error_message
                        "error_message": str(e),
                    },
                )
        else: 
            Http404("Invalid Request!")


    def get_tickers(request):
        
        tickers = []
        values = []
        if request:
            
            ticker_name = "ticker"
            value_name = "value"
            i = 1
            post = request.POST
            print("post is ", post)
            ticker_namei = ticker_name+str(i)
            value_namei = value_name+str(i)
            print("ticker name i is :", ticker_namei)
            while  ticker_namei in post:
                if value_namei in post:
                    if not post[value_namei] or not post[ticker_namei]:
                        pass
                    else: 
                        values.append(post[value_namei])
                        tickers.append(post[ticker_namei])
                    i += 1
                    ticker_namei = ticker_name+str(i)
                    value_namei = value_name+str(i)
                else:
                    raise ValueError(f"Request with no value for ticker:{post[ticker_namei]}")
            print("-------- tickers are ", tickers)
            print("-------- values are ", values)
            if not tickers or not values:
                raise ValueError("Request with no ticker name and value.")
            return tickers, values
        else:
            raise ValueError("Request with no ticker name and value.")


# We also specify the template_name for the results list view – this ensures that the results view and the detail view have a different appearance when rendered, even though they’re both a DetailView behind the scenes
class ResultsView(generic.DetailView):
    # model = Question
    template_name = "aiinvest/index.html"

def index(request):
    asset_list = AssetList.objects.all()

    # That code loads the template called aiinvest/index.html 
    template = loader.get_template("aiinvest/index.html")

    # create a dictionary as a context. 
    # this will be passed to render as an input args to render template.

    context = {
        "asset_list": asset_list,
    }

    # passes the template a context. The context is a dictionary mapping template variable names to Python objects.
    return HttpResponse(template.render(context,request))

    # or by 
    # return render(request, "polls/index.html", context)
    # The render() function takes the request object as its first argument, a template name as its second argument and a dictionary as its optional third argument. It returns an HttpResponse object of the given template rendered with the given context.

def test(request):

    # That code loads the template called aiinvest/index.html 
    template = loader.get_template("aiinvest/testfile.html")

    context = {
            "asset_data": "Place Holder",
        }

    # passes the template a context. The context is a dictionary mapping template variable names to Python objects.
    return HttpResponse(template.render(context,request))
